## 常数时间的操作

- +、-、\*、/、% 实际上都是 32 位的二进制运算，无论十进制的数值大小，常数时间是一样的
- 数组寻址，如 t = arr[1007],t = arr[99999999]，是通过一个偏移量直接取值的，无论下标大小，常数时间是一样的。需要注意一点，hash 函数也是常数时间
- 常数时间快慢 位运算 > 算数运算 > 寻址 > hash

## 非常数时间的操作

- 链表，链表在内存中是跳转结构，所以拿第 1 个节点和拿第 99999 个节点的时间是不一样的

# 时间复杂度

- 时间复杂度：用于描述算法运行时间和数据量大小的关系
- 只取最高阶，也就是 a\*n^2+b\*n+c 的时间复杂度是 O(n^2)
- 需要注意插入排序的具体运行时间和数据情况有关，但时间复杂度是取最差情况估计的。也就是说，严格固定流程的算法，都取最差的数据情况进行估计
- 但有流程上需要依靠随机行为的算法，时间复杂度需要通过计算期望来估计，因为最差的情况是无意义的
- 动态数组的扩容代价是均摊的，每次扩容的复杂度还是 O(1)
- 不要轻易的通过代码结构来判断时间复杂度，例如下方的代码，时间复杂度是 O(N \* log(N))的(N+N/2+N/3+N/4+.....+1)
  ```js
  for (let i = 1; i <= N; i++) {
    for (let j = i; j <= N; j += i) {}
  }
  ```

# 空间复杂度

- 又叫额外空间复杂度，不计算入参与返回的空间，计算的是为了支持整个算法流程，需要额外开辟的内存空间。
- 设计算法时，优先考虑时间复杂度，其次考虑空间复杂度
